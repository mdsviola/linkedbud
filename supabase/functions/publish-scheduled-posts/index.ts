// Supabase Edge Function for publishing scheduled posts to LinkedIn
// Triggered by a pg_cron job that runs every 30 minutes

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
// Import from bundled shared code (generated by npm run bundle:shared)
import { LinkedInClient } from "../_shared/linkedin/client.ts";
import { getLinkedInToken } from "../_shared/token-utils.ts";
import { sendPostPublishedNotificationEmail } from "../_shared/email/index.ts";

interface CronJobLog {
  id?: number;
  job_name: string;
  started_at: string;
  completed_at?: string;
  status: "running" | "completed" | "failed";
  posts_processed: number;
  successes: number;
  failures: number;
  error_details?: any;
}

interface ScheduledPost {
  id: number;
  user_id: string;
  scheduled_publish_date: string;
  publish_target: string;
  content: string;
  image_url: string | null;
  document_url: string | null;
  video_url: string | null;
}

serve(async (req) => {
  const startTime = new Date().toISOString();
  const jobName = "publish-scheduled-posts";
  let logId: number | null = null;

  // Production-ready structured logging
  const log = (
    level: "info" | "warn" | "error",
    message: string,
    context?: Record<string, any>
  ) => {
    const logEntry = {
      timestamp: new Date().toISOString(),
      level,
      service: "publish-scheduled-posts",
      message,
      ...(logId && { job_log_id: logId }),
      ...(context || {}),
    };

    const logString = JSON.stringify(logEntry);

    if (level === "error") {
      console.error(logString);
    } else if (level === "warn") {
      console.warn(logString);
    } else {
      console.log(logString);
    }
  };

  // Note: When called by pg_cron via net.http_post, the request doesn't have auth headers
  // But Edge Functions running in production automatically have access to SUPABASE_SERVICE_ROLE_KEY
  // via environment variables, so we can proceed without checking authorization headers

  try {
    log("info", "Starting scheduled post publishing job");

    // Initialize Supabase client
    const supabaseUrl = Deno.env.get("SUPABASE_URL");
    const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY");

    if (!supabaseUrl || !supabaseServiceKey) {
      const missingEnv = !supabaseUrl
        ? "SUPABASE_URL"
        : "SUPABASE_SERVICE_ROLE_KEY";
      log("error", `Missing required environment variable: ${missingEnv}`);
      throw new Error(`Missing required environment variable: ${missingEnv}`);
    }

    const supabase = createClient(supabaseUrl, supabaseServiceKey, {
      auth: {
        autoRefreshToken: false,
        persistSession: false,
      },
    });

    // Create initial log entry
    const { data: logData, error: logError } = await supabase
      .from("cron_job_logs")
      .insert({
        job_name: jobName,
        started_at: startTime,
        status: "running",
        posts_processed: 0,
        successes: 0,
        failures: 0,
      })
      .select()
      .single();

    if (logError) {
      log("error", "Failed to create log entry", { error: logError.message });
    } else {
      logId = logData.id;
      log("info", "Job started", { job_log_id: logId });
    }

    // Get all scheduled posts that are due to be published
    const now = new Date();
    const { data: posts, error: postsError } = await supabase
      .from("posts")
      .select(
        `
        id,
        user_id,
        scheduled_publish_date,
        publish_target,
        content,
        image_url,
        document_url,
        video_url
      `
      )
      .eq("status", "SCHEDULED")
      .not("scheduled_publish_date", "is", null)
      .lte("scheduled_publish_date", now.toISOString());

    if (postsError) {
      log("error", "Failed to fetch scheduled posts", {
        error: postsError.message,
        error_code: postsError.code,
        error_details: postsError.details,
        hint: postsError.hint,
      });
      throw new Error(`Failed to fetch posts: ${postsError.message}`);
    }

    if (!posts || posts.length === 0) {
      log("info", "No scheduled posts found", { count: 0 });
      await updateLog(supabase, logId, {
        status: "completed",
        completed_at: new Date().toISOString(),
        posts_processed: 0,
        successes: 0,
        failures: 0,
      });

      return new Response(
        JSON.stringify({
          processed: 0,
          succeeded: 0,
          failed: 0,
          errors: [],
          message: "No scheduled posts found that are due to be published",
        }),
        {
          headers: { "Content-Type": "application/json" },
          status: 200,
        }
      );
    }

    log("info", "Processing scheduled posts", { count: posts.length });

    // Process posts
    const result = await processPosts(supabase, posts, log);

    // Log final results
    log(result.failed > 0 ? "warn" : "info", "Job completed", {
      processed: result.processed,
      succeeded: result.succeeded,
      failed: result.failed,
    });

    // Update log with final results
    await updateLog(supabase, logId, {
      status: result.failed > 0 ? "failed" : "completed",
      completed_at: new Date().toISOString(),
      posts_processed: result.processed,
      successes: result.succeeded,
      failures: result.failed,
      error_details: result.errors.length > 0 ? result.errors : null,
    });

    return new Response(JSON.stringify(result), {
      headers: { "Content-Type": "application/json" },
      status: 200,
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : undefined;

    log("error", "Edge function error", {
      error: errorMessage,
      stack: errorStack,
    });

    // Update log with error
    if (logId) {
      try {
        const supabaseUrl = Deno.env.get("SUPABASE_URL")!;
        const supabaseServiceKey = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;
        const supabase = createClient(supabaseUrl, supabaseServiceKey);

        await updateLog(supabase, logId, {
          status: "failed",
          completed_at: new Date().toISOString(),
          error_details: errorMessage,
        });
      } catch (logUpdateError) {
        log("error", "Failed to update log with error", {
          error:
            logUpdateError instanceof Error
              ? logUpdateError.message
              : String(logUpdateError),
        });
      }
    }

    return new Response(
      JSON.stringify({
        error: errorMessage,
        processed: 0,
        succeeded: 0,
        failed: 0,
        errors: [errorMessage],
      }),
      {
        headers: { "Content-Type": "application/json" },
        status: 500,
      }
    );
  }
});

interface ProcessResult {
  processed: number;
  succeeded: number;
  failed: number;
  errors: string[];
}

// Helper function to extract file path from Supabase storage URL
function extractFilePathFromUrl(url: string): string | null {
  try {
    const match = url.match(/\/storage\/v1\/object\/public\/[^/]+\/(.+)$/);
    return match ? match[1] : null;
  } catch {
    return null;
  }
}

// Helper function to extract filename from storage path
function getFilenameFromPath(path: string | null): string {
  if (!path) return "file";
  const parts = path.split("/");
  return parts[parts.length - 1] || "file";
}

// Helper function to download file from Supabase storage (Deno-compatible)
async function downloadFileFromStorage(
  supabase: any,
  storagePath: string | null
): Promise<Uint8Array | null> {
  if (!storagePath) return null;

  try {
    const STORAGE_BUCKET = "storage";
    const { data, error } = await supabase.storage
      .from(STORAGE_BUCKET)
      .download(storagePath);

    if (error) {
      // Silent fail - caller will handle logging with context
      return null;
    }

    if (!data) {
      // Silent fail - caller will handle logging with context
      return null;
    }

    // Convert Blob to Uint8Array for Deno
    const arrayBuffer = await data.arrayBuffer();
    return new Uint8Array(arrayBuffer);
  } catch (error) {
    // Silent fail - caller will handle logging with context
    return null;
  }
}

async function processPosts(
  supabase: any,
  posts: ScheduledPost[],
  log: (
    level: "info" | "warn" | "error",
    message: string,
    context?: Record<string, any>
  ) => void
): Promise<ProcessResult> {
  const result: ProcessResult = {
    processed: 0,
    succeeded: 0,
    failed: 0,
    errors: [],
  };

  // Process each post
  const updatePromises = posts.map(async (post) => {
    try {
      result.processed++;

      // Validate content exists
      if (!post.content || post.content.trim().length === 0) {
        throw new Error("Post content is empty");
      }

      const content = post.content;

      // Determine token type based on publish target
      const tokenType =
        post.publish_target === "personal" ? "personal" : "community";
      const token = await getLinkedInToken(post.user_id, tokenType);

      if (!token) {
        throw new Error(
          `LinkedIn token not found or expired for user ${post.user_id}`
        );
      }

      // Create LinkedIn API instance using shared client
      const linkedinAPI = new LinkedInClient(token.access_token);

      // Determine author URN based on publish target
      let authorUrn: string | undefined;
      let organizationId: string | undefined;

      if (tokenType === "personal") {
        authorUrn = undefined; // Will use personal profile
        organizationId = undefined;
      } else {
        authorUrn = `urn:li:organization:${post.publish_target}`;
        organizationId = post.publish_target;
      }

      // Handle attachments: download and upload to LinkedIn
      let imageAssetUrn: string | undefined;
      let documentAssetUrn: string | undefined;
      let videoAssetUrn: string | undefined;

      // Handle image upload
      if (post.image_url) {
        try {
          // Extract storage path (handle both full URLs and paths)
          let imagePath = post.image_url;
          if (
            post.image_url.startsWith("http://") ||
            post.image_url.startsWith("https://")
          ) {
            const extracted = extractFilePathFromUrl(post.image_url);
            if (extracted) {
              imagePath = extracted;
            } else {
              log("warn", "Could not extract path from image URL", {
                post_id: post.id,
                image_url: post.image_url,
              });
              imagePath = null;
            }
          }

          if (imagePath) {
            const imageBuffer = await downloadFileFromStorage(
              supabase,
              imagePath
            );
            if (imageBuffer) {
              const filename = getFilenameFromPath(imagePath);
              imageAssetUrn = await linkedinAPI.uploadImageAsset(
                imageBuffer,
                filename,
                authorUrn
              );
              log("info", "Image uploaded successfully", {
                post_id: post.id,
                image_path: imagePath,
              });
            } else {
              log("warn", "Failed to download image from storage", {
                post_id: post.id,
                image_path: imagePath,
              });
            }
          }
        } catch (error) {
          log("error", "Error uploading image to LinkedIn", {
            post_id: post.id,
            error: error instanceof Error ? error.message : String(error),
          });
          // Continue without image - publish text-only post
        }
      }

      // Handle document upload
      if (post.document_url) {
        try {
          // Extract storage path (handle both full URLs and paths)
          let documentPath = post.document_url;
          if (
            post.document_url.startsWith("http://") ||
            post.document_url.startsWith("https://")
          ) {
            const extracted = extractFilePathFromUrl(post.document_url);
            if (extracted) {
              documentPath = extracted;
            } else {
              log("warn", "Could not extract path from document URL", {
                post_id: post.id,
                document_url: post.document_url,
              });
              documentPath = null;
            }
          }

          if (documentPath) {
            const documentBuffer = await downloadFileFromStorage(
              supabase,
              documentPath
            );
            if (documentBuffer) {
              const filename = getFilenameFromPath(documentPath);
              documentAssetUrn = await linkedinAPI.uploadDocumentAsset(
                documentBuffer,
                filename,
                authorUrn
              );
              log("info", "Document uploaded successfully", {
                post_id: post.id,
                document_path: documentPath,
              });
            } else {
              log("warn", "Failed to download document from storage", {
                post_id: post.id,
                document_path: documentPath,
              });
            }
          }
        } catch (error) {
          log("error", "Error uploading document to LinkedIn", {
            post_id: post.id,
            error: error instanceof Error ? error.message : String(error),
          });
          // Continue without document - publish text-only post
        }
      }

      // Handle video upload
      if (post.video_url) {
        try {
          // Extract storage path (handle both full URLs and paths)
          let videoPath = post.video_url;
          if (
            post.video_url.startsWith("http://") ||
            post.video_url.startsWith("https://")
          ) {
            const extracted = extractFilePathFromUrl(post.video_url);
            if (extracted) {
              videoPath = extracted;
            } else {
              log("warn", "Could not extract path from video URL", {
                post_id: post.id,
                video_url: post.video_url,
              });
              videoPath = null;
            }
          }

          if (videoPath) {
            const videoBuffer = await downloadFileFromStorage(
              supabase,
              videoPath
            );
            if (videoBuffer) {
              const filename = getFilenameFromPath(videoPath);
              videoAssetUrn = await linkedinAPI.uploadVideoAsset(
                videoBuffer,
                filename,
                authorUrn
              );
              log("info", "Video uploaded successfully", {
                post_id: post.id,
                video_path: videoPath,
              });
            } else {
              log("warn", "Failed to download video from storage", {
                post_id: post.id,
                video_path: videoPath,
              });
            }
          }
        } catch (error) {
          log("error", "Error uploading video to LinkedIn", {
            post_id: post.id,
            error: error instanceof Error ? error.message : String(error),
          });
          // Continue without video - publish text-only post
        }
      }

      // Publish to LinkedIn with optional media
      const linkedinResponse = await linkedinAPI.publishPost(
        content,
        authorUrn,
        imageAssetUrn,
        documentAssetUrn,
        videoAssetUrn
      );

      // Log the successful LinkedIn post
      await logLinkedInPost(
        supabase,
        post.user_id,
        post.id,
        linkedinResponse.id,
        content,
        "PUBLISHED",
        organizationId,
        undefined
      );

      // Update the post status
      const { error: updateError } = await supabase
        .from("posts")
        .update({
          status: "PUBLISHED",
          published_at: new Date().toISOString(),
        })
        .eq("id", post.id)
        .eq("user_id", post.user_id);

      if (updateError) {
        log("error", "Failed to update post status", {
          post_id: post.id,
          error: updateError.message,
        });
      }

      result.succeeded++;
      log("info", "Post published successfully", {
        post_id: post.id,
        user_id: post.user_id,
        linkedin_post_id: linkedinResponse.id,
        organization_id: organizationId || null,
      });

      // Send email notification to user (async, don't wait)
      // Log that we're attempting to send email
      log("info", "Attempting to send post published notification email", {
        post_id: post.id,
        user_id: post.user_id,
      });

      sendPostPublishedNotificationEmailToUser(
        supabase,
        post.user_id,
        post.id,
        log
      ).catch((emailError) => {
        log("error", "Failed to send post published notification email", {
          post_id: post.id,
          user_id: post.user_id,
          error:
            emailError instanceof Error
              ? emailError.message
              : String(emailError),
          stack: emailError instanceof Error ? emailError.stack : undefined,
        });
        // Don't fail the post publication if email fails
      });
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : String(error);
      result.failed++;
      result.errors.push(
        `Post ${post.id} (User: ${post.user_id}): ${errorMessage}`
      );
      log("error", "Failed to publish post", {
        post_id: post.id,
        user_id: post.user_id,
        error: errorMessage,
        stack: error instanceof Error ? error.stack : undefined,
      });

      // Note: We don't update post status to FAILED since schema only allows DRAFT, SCHEDULED, PUBLISHED, ARCHIVED
      // The error is logged in linkedin_posts table instead
      try {
        // Optionally, we could update to DRAFT or ARCHIVED, but leaving as SCHEDULED
        // so user can retry manually
        // await supabase
        //   .from("posts")
        //   .update({
        //     status: "DRAFT",
        //   })
        //   .eq("id", post.id)
        //   .eq("user_id", post.user_id);

        // Log the failed LinkedIn post
        await logLinkedInPost(
          supabase,
          post.user_id,
          post.id,
          "",
          post.content || "Failed to get post content",
          "FAILED",
          undefined,
          error.message
        );
      } catch (updateError) {
        log("error", "Failed to log failed post", {
          post_id: post.id,
          error:
            updateError instanceof Error
              ? updateError.message
              : String(updateError),
        });
      }
    }
  });

  await Promise.all(updatePromises);

  // Log summary
  log(result.failed > 0 ? "warn" : "info", "All posts processed", {
    processed: result.processed,
    succeeded: result.succeeded,
    failed: result.failed,
  });

  return result;
}

async function logLinkedInPost(
  supabase: any,
  userId: string,
  postId: number,
  linkedinPostId: string,
  content: string,
  status: "PUBLISHED" | "FAILED",
  organizationId?: string,
  errorMessage?: string
): Promise<void> {
  const linkedinPostRecord: any = {
    user_id: userId,
    post_id: postId,
    content: content,
    status: status,
    organization_id: organizationId,
  };

  if (status === "PUBLISHED") {
    linkedinPostRecord.linkedin_post_id = linkedinPostId;
    linkedinPostRecord.published_at = new Date().toISOString();
  } else {
    linkedinPostRecord.error_message = errorMessage;
  }

  const { error: logError } = await supabase
    .from("linkedin_posts")
    .insert(linkedinPostRecord);

  if (logError) {
    // Note: This is called from processPosts which has access to log function
    // but we don't want to pass it through. Use console.error as fallback.
    console.error(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        level: "error",
        service: "publish-scheduled-posts",
        message: "Failed to log LinkedIn post",
        post_id: postId,
        user_id: userId,
        status,
        error: logError.message,
      })
    );
  }
}

async function updateLog(
  supabase: any,
  logId: number | null,
  updates: Partial<CronJobLog>
): Promise<void> {
  if (!logId) return;

  const { error } = await supabase
    .from("cron_job_logs")
    .update(updates)
    .eq("id", logId);

  if (error) {
    // Note: This is called from places that may not have log function in scope
    console.error(
      JSON.stringify({
        timestamp: new Date().toISOString(),
        level: "error",
        service: "publish-scheduled-posts",
        message: "Failed to update cron job log",
        job_log_id: logId,
        error: error.message,
      })
    );
  }
}

/**
 * Send post published notification email to user
 */
async function sendPostPublishedNotificationEmailToUser(
  supabase: any,
  userId: string,
  postId: number,
  log: (
    level: "info" | "warn" | "error",
    message: string,
    context?: Record<string, any>
  ) => void
): Promise<void> {
  try {
    // Check if RESEND_API_KEY is set
    const resendApiKey = Deno.env.get("RESEND_API_KEY");
    if (!resendApiKey) {
      log("error", "RESEND_API_KEY not set, skipping email notification", {
        user_id: userId,
        post_id: postId,
        note: "Set RESEND_API_KEY environment variable in Supabase Edge Function settings",
      });
      return;
    }

    log("info", "Fetching user profile for email notification", {
      user_id: userId,
      post_id: postId,
    });

    // Get user email from profiles table
    const { data: profile, error: profileError } = await supabase
      .from("profiles")
      .select("email")
      .eq("id", userId)
      .single();

    if (profileError) {
      log("error", "Failed to fetch user profile for notification", {
        user_id: userId,
        post_id: postId,
        error: profileError.message,
        error_code: profileError.code,
        error_details: profileError.details,
      });
      return;
    }

    if (!profile || !profile.email) {
      log("error", "User profile not found or email missing", {
        user_id: userId,
        post_id: postId,
        profile_exists: !!profile,
        email_present: !!profile?.email,
      });
      return;
    }

    // Get app URL from environment or use default
    const appUrl =
      Deno.env.get("NEXT_PUBLIC_APP_URL") || "https://linkedbud.com";
    const postUrl = `${appUrl}/posts/${postId}`;

    // Get sender email
    const senderEmail =
      Deno.env.get("RESEND_FROM_EMAIL") || "onboarding@resend.dev";

    log("info", "Sending post published notification email", {
      user_id: userId,
      post_id: postId,
      email: profile.email,
      sender_email: senderEmail,
      post_url: postUrl,
    });

    // Send email using shared utility
    const result = await sendPostPublishedNotificationEmail(
      resendApiKey,
      {
        email: profile.email,
        name: null, // Profiles table doesn't store name, use email-based name
      },
      postUrl,
      appUrl,
      senderEmail
    );

    log("info", "Post published notification email sent successfully", {
      user_id: userId,
      post_id: postId,
      email: profile.email,
      resend_id: result.id,
    });
  } catch (error) {
    // Log error but don't throw - email failure shouldn't break post publication
    log("error", "Error sending post published notification email", {
      user_id: userId,
      post_id: postId,
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      error_type: error?.constructor?.name || typeof error,
    });
  }
}
