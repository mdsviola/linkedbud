-- Portfolio collaboration tables (defined before profiles, but foreign key added after)
CREATE TABLE public.portfolios (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid NOT NULL UNIQUE, -- Foreign key to profiles added after profiles table is created
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- User profile information
CREATE TABLE public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email text UNIQUE,
  first_name text,
  last_name text,
  role text DEFAULT 'user', -- 'user' or 'admin'
  portfolio_id uuid REFERENCES public.portfolios(id) ON DELETE SET NULL,
  created_at timestamptz DEFAULT now()
);

-- Add foreign key constraint to portfolios after profiles is created
ALTER TABLE public.portfolios
  ADD CONSTRAINT portfolios_owner_id_fkey FOREIGN KEY (owner_id) REFERENCES public.profiles(id) ON DELETE CASCADE;

-- Add comments to document the columns
COMMENT ON COLUMN public.profiles.role IS 'User role: user or admin';
COMMENT ON COLUMN public.profiles.first_name IS 'User first name';
COMMENT ON COLUMN public.profiles.last_name IS 'User last name';

-- User preferences and AI customization settings
CREATE TABLE public.user_prefs (
  user_id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  topics text[] DEFAULT '{}', -- News topics for content filtering (renamed from industry_keywords)
  tone text DEFAULT 'expert', -- AI tone: 'expert', 'witty', 'formal', 'challenger'
  email_reminders boolean DEFAULT true,
  user_corpus jsonb, -- Past LinkedIn posts for tone extraction
  custom_rss_feeds text[] DEFAULT '{}', -- Custom RSS feeds for news
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);



-- AI-generated content posts
CREATE TABLE public.posts (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  portfolio_id uuid REFERENCES public.portfolios(id) ON DELETE SET NULL,
  two_para_summary text NOT NULL,
  content text NOT NULL, -- The post content text
  status text DEFAULT 'DRAFT' CHECK (status IN ('DRAFT', 'SCHEDULED', 'PUBLISHED', 'ARCHIVED')),
  scheduled_publish_date timestamptz, -- When the post is scheduled to be published (UTC)
  publish_target text, -- LinkedIn account target: "personal" or organization ID
  published_at timestamptz, -- When the post was actually published (UTC)
  source_url text, -- URL of the source article
  source_title text, -- Title of the source article
  source_content text, -- Scraped article content for regeneration and improvements
  keywords text[], -- Array of 5 keywords generated by OpenAI based on post content
  image_url text, -- Relative path of uploaded image file in Supabase storage (e.g., "posts/[user_id]/[post_id]/images/[filename]")
  document_url text, -- Relative path of uploaded document file in Supabase storage (e.g., "posts/[user_id]/[post_id]/docs/[filename]")
  video_url text, -- Relative path of uploaded video file in Supabase storage (e.g., "posts/[user_id]/[post_id]/videos/[filename]")
  created_at timestamptz DEFAULT now()
);

-- Add comment to document the content column
COMMENT ON COLUMN public.posts.content IS 'The post content text';

-- Add comment to document the keywords column
COMMENT ON COLUMN public.posts.keywords IS 'Array of 5 keywords generated by OpenAI based on post content';

-- Add comment to document the image_url column
COMMENT ON COLUMN public.posts.image_url IS 'Relative path of uploaded image file in Supabase storage (e.g., "posts/[user_id]/[post_id]/images/[filename]")';

-- Add comment to document the document_url column
COMMENT ON COLUMN public.posts.document_url IS 'Relative path of uploaded document file in Supabase storage (e.g., "posts/[user_id]/[post_id]/docs/[filename]")';

-- Add comment to document the video_url column
COMMENT ON COLUMN public.posts.video_url IS 'Relative path of uploaded video file in Supabase storage (e.g., "posts/[user_id]/[post_id]/videos/[filename]")';

-- Add comment to document the publish_target column
COMMENT ON COLUMN public.posts.publish_target IS 'LinkedIn account target: "personal" or organization ID. Used to categorize posts by their intended or actual publish target for tab filtering.';

-- Manual engagement tracking for posted content
CREATE TABLE public.engagement_logs (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  post_id bigint REFERENCES public.posts(id) ON DELETE SET NULL,
  posted_at timestamptz,
  impressions int,
  likes int,
  comments int,
  notes text,
  created_at timestamptz DEFAULT now()
);

-- Subscription management
CREATE TABLE public.subscriptions (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  provider text NOT NULL, -- 'lemonsqueezy'
  status text NOT NULL, -- 'active', 'canceled', 'past_due'
  external_customer_id text,
  external_subscription_id text,
  price_id text,
  membership_type text CHECK (membership_type IN ('membership', 'addon', 'growth_member')),
  current_period_end timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Usage tracking for billing limits (type-based tracking)
CREATE TABLE public.usage_counters (
  user_id uuid PRIMARY KEY REFERENCES public.profiles(id) ON DELETE CASCADE,
  total_generations int DEFAULT 0, -- Keep for backward compatibility
  generation_counts jsonb DEFAULT '{}'::jsonb -- New type-based tracking: {"draft": 5, "polish": 2, "for_you": 10}
);

-- Feature cooldowns - generic table for tracking when users last used features
-- This allows cooldown periods for various features (ideas generation, etc.)
CREATE TABLE public.feature_cooldowns (
  id bigserial PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  feature_name text NOT NULL, -- e.g., 'ideas_generation', 'custom_generation', etc.
  last_used_at timestamptz NOT NULL DEFAULT now(),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, feature_name)
);

-- Index for faster lookups
CREATE INDEX idx_feature_cooldowns_user_feature ON public.feature_cooldowns(user_id, feature_name);

-- Comment to document the table
COMMENT ON TABLE public.feature_cooldowns IS 'Tracks when users last used features to enforce cooldown periods';
COMMENT ON COLUMN public.feature_cooldowns.feature_name IS 'Unique identifier for the feature (e.g., ideas_generation, custom_generation)';
COMMENT ON COLUMN public.feature_cooldowns.last_used_at IS 'Timestamp when the user last used this feature';

-- LinkedIn integration tables
CREATE TABLE public.linkedin_accounts (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  linkedin_user_id text NOT NULL,
  access_token text NOT NULL,
  refresh_token text,
  token_expires_at timestamptz,
  profile_data jsonb, -- Store LinkedIn profile info
  account_type text DEFAULT 'personal' CHECK (account_type IN ('personal', 'organization')),
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, linkedin_user_id)
);

-- LinkedIn publishing logs table
CREATE TABLE public.linkedin_posts (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  post_id bigint REFERENCES public.posts(id) ON DELETE SET NULL,
  linkedin_post_id text, -- LinkedIn's post ID
  content text NOT NULL,
  status text DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'PUBLISHED', 'FAILED')),
  error_message text,
  published_at timestamptz,
  organization_id text, -- LinkedIn organization ID when posting to an organization, NULL for personal posts
  created_at timestamptz DEFAULT now()
);

-- Store organization pages user has access to
CREATE TABLE public.linkedin_organizations (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  linkedin_org_id text NOT NULL,
  org_name text,
  org_vanity_name text,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, linkedin_org_id)
);

-- Store post performance metrics
CREATE TABLE public.linkedin_post_metrics (
  id bigserial PRIMARY KEY,
  linkedin_post_id text NOT NULL,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  impressions bigint DEFAULT 0,
  likes bigint DEFAULT 0,
  comments bigint DEFAULT 0,
  shares bigint DEFAULT 0,
  clicks bigint DEFAULT 0,
  engagement_rate decimal(5,4), -- Store as decimal for precision
  fetched_at timestamptz DEFAULT now(),
  created_at timestamptz DEFAULT now(),
  UNIQUE(linkedin_post_id, user_id, fetched_at)
);

-- Unified LinkedIn tokens table for both personal and community tokens
CREATE TABLE public.linkedin_tokens (
  id bigserial PRIMARY KEY,
  user_id uuid REFERENCES public.profiles(id) ON DELETE CASCADE,
  type text NOT NULL CHECK (type IN ('personal', 'community')),
  access_token text NOT NULL,
  refresh_token text,
  token_expires_at timestamptz,
  linkedin_user_id text, -- For personal tokens
  profile_data jsonb, -- For personal profile info
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, type) -- One token per type per user
);

-- Cron job logs table for tracking Edge Function execution
CREATE TABLE public.cron_job_logs (
  id bigserial PRIMARY KEY,
  job_name text NOT NULL,
  started_at timestamptz DEFAULT now(),
  completed_at timestamptz,
  status text NOT NULL CHECK (status IN ('running', 'completed', 'failed')),
  posts_processed integer DEFAULT 0,
  successes integer DEFAULT 0,
  failures integer DEFAULT 0,
  error_details jsonb,
  created_at timestamptz DEFAULT now()
);

-- Add comments for cron_job_logs table
COMMENT ON TABLE public.cron_job_logs IS 'Logs for Supabase cron jobs, tracking execution and results.';
COMMENT ON COLUMN public.cron_job_logs.job_name IS 'Name of the cron job.';
COMMENT ON COLUMN public.cron_job_logs.status IS 'Status of the cron job: running, completed, or failed.';
COMMENT ON COLUMN public.cron_job_logs.posts_processed IS 'Number of posts attempted to process.';
COMMENT ON COLUMN public.cron_job_logs.successes IS 'Number of posts successfully processed.';
COMMENT ON COLUMN public.cron_job_logs.failures IS 'Number of posts that failed processing.';
COMMENT ON COLUMN public.cron_job_logs.error_details IS 'JSON object containing details of errors, if any.';

-- Waitlist table for pre-launch interest registration
CREATE TABLE public.waitlist (
  id bigserial PRIMARY KEY,
  email text UNIQUE NOT NULL,
  created_at timestamptz DEFAULT now(),
  notified_at timestamptz NULL -- tracks when launch email was sent
);

-- Add comment to document the waitlist table
COMMENT ON TABLE public.waitlist IS 'Email addresses of users interested in the platform before launch';
COMMENT ON COLUMN public.waitlist.notified_at IS 'Timestamp when launch notification email was sent, NULL if not yet notified';

CREATE TABLE public.portfolio_collaborators (
  id bigserial PRIMARY KEY,
  portfolio_id uuid NOT NULL REFERENCES public.portfolios(id) ON DELETE CASCADE,
  user_id uuid NOT NULL UNIQUE REFERENCES public.profiles(id) ON DELETE CASCADE,
  invited_by uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'declined')),
  invited_at timestamptz DEFAULT now(),
  accepted_at timestamptz,
  UNIQUE(portfolio_id, user_id)
);

CREATE TABLE public.portfolio_invitations (
  id bigserial PRIMARY KEY,
  portfolio_id uuid NOT NULL REFERENCES public.portfolios(id) ON DELETE CASCADE,
  email text NOT NULL,
  token text NOT NULL UNIQUE,
  invited_by uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  status text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'accepted', 'expired', 'declined')),
  expires_at timestamptz NOT NULL,
  created_at timestamptz DEFAULT now()
);

-- Add comments for portfolio tables
COMMENT ON TABLE public.portfolios IS 'Portfolios owned by Growth plan users for collaboration';
COMMENT ON TABLE public.portfolio_collaborators IS 'Users who collaborate on portfolios';
COMMENT ON TABLE public.portfolio_invitations IS 'Pending invitations to join portfolios';
COMMENT ON COLUMN public.subscriptions.membership_type IS 'Type of subscription: membership (main paid subscription), addon (extra seats/addons), or growth_member (collaborator with Growth tier access)';

-- Enable Row Level Security on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_prefs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.engagement_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.usage_counters ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.feature_cooldowns ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linkedin_accounts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linkedin_posts ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linkedin_organizations ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linkedin_post_metrics ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.linkedin_tokens ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.cron_job_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.waitlist ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.portfolios ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.portfolio_collaborators ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.portfolio_invitations ENABLE ROW LEVEL SECURITY;

-- Admin function for policy checks
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean
LANGUAGE sql
SECURITY DEFINER
STABLE
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles
    WHERE id = (select auth.uid())
    AND role = 'admin'
  );
$$;

-- RLS Policies: User data access control
CREATE POLICY "Users can view own profile" ON public.profiles
  FOR SELECT USING ((select auth.uid()) = id);

CREATE POLICY "Users can update own profile" ON public.profiles
  FOR UPDATE USING ((select auth.uid()) = id);

CREATE POLICY "Users can insert own profile" ON public.profiles
  FOR INSERT WITH CHECK ((select auth.uid()) = id);

CREATE POLICY "Users can manage own preferences" ON public.user_prefs
  FOR ALL USING ((select auth.uid()) = user_id);



-- User-specific content and data
-- Note: Posts policy updated to use portfolio access function and optimized for performance
-- Consolidated user and service role policies into single policy
CREATE POLICY "Users and service role can manage posts" ON public.posts
  FOR ALL USING (
    (select auth.uid()) = user_id OR
    public.can_user_access_post((select auth.uid()), id) OR
    ((select auth.jwt()) ->> 'role' = 'service_role')
  );

CREATE POLICY "Users can manage own engagement logs" ON public.engagement_logs
  FOR ALL USING ((select auth.uid()) = user_id);

-- Consolidated user and admin policies for subscriptions
CREATE POLICY "Users and admins can manage subscriptions" ON public.subscriptions
  FOR ALL USING (
    (select auth.uid()) = user_id OR
    public.is_admin()
  );

-- Consolidated user and admin policies for usage counters
CREATE POLICY "Users and admins can manage usage counters" ON public.usage_counters
  FOR ALL USING (
    (select auth.uid()) = user_id OR
    public.is_admin()
  );

CREATE POLICY "Users can manage own feature cooldowns" ON public.feature_cooldowns
  FOR ALL USING ((select auth.uid()) = user_id);

-- LinkedIn account policies
CREATE POLICY "Users can view own linkedin accounts" ON public.linkedin_accounts
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own linkedin accounts" ON public.linkedin_accounts
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own linkedin accounts" ON public.linkedin_accounts
  FOR UPDATE USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can delete own linkedin accounts" ON public.linkedin_accounts
  FOR DELETE USING ((select auth.uid()) = user_id);

-- LinkedIn posts policies
CREATE POLICY "Users can view own linkedin posts" ON public.linkedin_posts
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own linkedin posts" ON public.linkedin_posts
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own linkedin posts" ON public.linkedin_posts
  FOR UPDATE USING ((select auth.uid()) = user_id);

-- LinkedIn organizations policies
CREATE POLICY "Users can view own linkedin organizations" ON public.linkedin_organizations
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own linkedin organizations" ON public.linkedin_organizations
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own linkedin organizations" ON public.linkedin_organizations
  FOR UPDATE USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can delete own linkedin organizations" ON public.linkedin_organizations
  FOR DELETE USING ((select auth.uid()) = user_id);

-- LinkedIn post metrics policies
CREATE POLICY "Users can view own linkedin post metrics" ON public.linkedin_post_metrics
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own linkedin post metrics" ON public.linkedin_post_metrics
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own linkedin post metrics" ON public.linkedin_post_metrics
  FOR UPDATE USING ((select auth.uid()) = user_id);

-- LinkedIn tokens policies
CREATE POLICY "Users can view own linkedin tokens" ON public.linkedin_tokens
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own linkedin tokens" ON public.linkedin_tokens
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own linkedin tokens" ON public.linkedin_tokens
  FOR UPDATE USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can delete own linkedin tokens" ON public.linkedin_tokens
  FOR DELETE USING ((select auth.uid()) = user_id);

-- Cron job logs policies
CREATE POLICY "Allow authenticated users to view cron job logs" ON public.cron_job_logs
  FOR SELECT USING ((select auth.role()) = 'authenticated');

CREATE POLICY "Allow service role to insert cron job logs" ON public.cron_job_logs
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Allow service role to update cron job logs" ON public.cron_job_logs
  FOR UPDATE USING (true);

-- Waitlist policies
CREATE POLICY "Anyone can insert into waitlist" ON public.waitlist
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Admins can view all waitlist entries" ON public.waitlist
  FOR SELECT USING (public.is_admin());

-- Admin policies
-- Note: Admin policies for subscriptions and usage_counters are consolidated with user policies above
CREATE POLICY "Admins can view all profiles" ON public.profiles
  FOR SELECT USING (public.is_admin());

-- Portfolio RLS Policies
CREATE POLICY "Users can view own portfolio" ON public.portfolios
  FOR SELECT USING (
    (select auth.uid()) = owner_id OR
    EXISTS (
      SELECT 1 FROM public.portfolio_collaborators
      WHERE portfolio_id = portfolios.id
      AND user_id = (select auth.uid())
      AND status = 'accepted'
    )
  );

CREATE POLICY "Users can insert own portfolio" ON public.portfolios
  FOR INSERT WITH CHECK ((select auth.uid()) = owner_id);

CREATE POLICY "Users can update own portfolio" ON public.portfolios
  FOR UPDATE USING ((select auth.uid()) = owner_id);

-- Consolidated portfolio_collaborators policy for both viewing and management
CREATE POLICY "Portfolio members and owners can manage collaborators" ON public.portfolio_collaborators
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.portfolios
      WHERE id = portfolio_collaborators.portfolio_id
      AND (
        owner_id = (select auth.uid()) OR
        EXISTS (
          SELECT 1 FROM public.portfolio_collaborators pc
          WHERE pc.portfolio_id = portfolio_collaborators.portfolio_id
          AND pc.user_id = (select auth.uid())
          AND pc.status = 'accepted'
        )
      )
    )
  );

CREATE POLICY "Portfolio owners can view invitations" ON public.portfolio_invitations
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM public.portfolios
      WHERE id = portfolio_invitations.portfolio_id
      AND owner_id = (select auth.uid())
    )
  );

CREATE POLICY "Portfolio owners can create invitations" ON public.portfolio_invitations
  FOR INSERT WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.portfolios
      WHERE id = portfolio_invitations.portfolio_id
      AND owner_id = (select auth.uid())
    )
  );

CREATE POLICY "Portfolio owners can update invitations" ON public.portfolio_invitations
  FOR UPDATE USING (
    EXISTS (
      SELECT 1 FROM public.portfolios
      WHERE id = portfolio_invitations.portfolio_id
      AND owner_id = (select auth.uid())
    )
  );

-- Performance indexes
CREATE INDEX idx_posts_user_created ON public.posts(user_id, created_at DESC);
CREATE INDEX idx_posts_status ON public.posts(status);
CREATE INDEX idx_posts_user_status ON public.posts(user_id, status);
CREATE INDEX idx_posts_scheduled_publish_date ON public.posts(scheduled_publish_date);
CREATE INDEX idx_posts_published_at ON public.posts(published_at);
CREATE INDEX idx_engagement_logs_user_created ON public.engagement_logs(user_id, created_at DESC);
CREATE INDEX idx_subscriptions_user_status ON public.subscriptions(user_id, status);

-- LinkedIn account indexes
CREATE INDEX idx_linkedin_accounts_user_id ON public.linkedin_accounts(user_id);
CREATE INDEX idx_linkedin_accounts_linkedin_user_id ON public.linkedin_accounts(linkedin_user_id);

-- LinkedIn posts indexes
CREATE INDEX idx_linkedin_posts_user_id ON public.linkedin_posts(user_id);
CREATE INDEX idx_linkedin_posts_post_id ON public.linkedin_posts(post_id);
CREATE INDEX idx_linkedin_posts_linkedin_post_id ON public.linkedin_posts(linkedin_post_id);
CREATE INDEX idx_linkedin_posts_organization_id ON public.linkedin_posts(organization_id);
CREATE INDEX idx_linkedin_posts_user_organization ON public.linkedin_posts(user_id, organization_id);

-- LinkedIn organizations indexes
CREATE INDEX idx_linkedin_organizations_user_id ON public.linkedin_organizations(user_id);
CREATE INDEX idx_linkedin_organizations_linkedin_org_id ON public.linkedin_organizations(linkedin_org_id);

-- LinkedIn post metrics indexes
CREATE INDEX idx_linkedin_post_metrics_user_id ON public.linkedin_post_metrics(user_id);
CREATE INDEX idx_linkedin_post_metrics_linkedin_post_id ON public.linkedin_post_metrics(linkedin_post_id);
CREATE INDEX idx_linkedin_post_metrics_fetched_at ON public.linkedin_post_metrics(fetched_at);
CREATE UNIQUE INDEX idx_linkedin_post_metrics_unique ON public.linkedin_post_metrics(linkedin_post_id, fetched_at);

-- LinkedIn tokens indexes
CREATE INDEX idx_linkedin_tokens_user_id ON public.linkedin_tokens(user_id);
CREATE INDEX idx_linkedin_tokens_type ON public.linkedin_tokens(type);
CREATE INDEX idx_linkedin_tokens_user_type ON public.linkedin_tokens(user_id, type);

-- Waitlist indexes
CREATE INDEX idx_waitlist_email ON public.waitlist(email);
CREATE INDEX idx_waitlist_created_at ON public.waitlist(created_at DESC);

-- Posts source indexes
CREATE INDEX idx_posts_source_url ON public.posts(source_url);

-- Portfolio indexes
CREATE INDEX idx_portfolios_owner_id ON public.portfolios(owner_id);
CREATE INDEX idx_portfolio_collaborators_portfolio_id ON public.portfolio_collaborators(portfolio_id);
CREATE INDEX idx_portfolio_collaborators_user_id ON public.portfolio_collaborators(user_id);
CREATE INDEX idx_portfolio_invitations_portfolio_id ON public.portfolio_invitations(portfolio_id);
CREATE INDEX idx_portfolio_invitations_token ON public.portfolio_invitations(token);
CREATE INDEX idx_portfolio_invitations_email ON public.portfolio_invitations(email);
CREATE INDEX idx_profiles_portfolio_id ON public.profiles(portfolio_id);
CREATE INDEX idx_posts_portfolio_id ON public.posts(portfolio_id);
CREATE INDEX idx_posts_portfolio_user ON public.posts(portfolio_id, user_id);

-- Feedback submissions table
CREATE TABLE public.feedback_submissions (
  id bigserial PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  email text NOT NULL,
  type text NOT NULL CHECK (type IN ('issue', 'idea', 'other')),
  message text NOT NULL,
  screenshot_url text,
  device_info jsonb,
  status text DEFAULT 'new' CHECK (status IN ('new', 'reviewed', 'resolved')),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Add comments for feedback_submissions
COMMENT ON TABLE public.feedback_submissions IS 'User feedback submissions with screenshots';
COMMENT ON COLUMN public.feedback_submissions.type IS 'Type of feedback: issue, idea, or other';
COMMENT ON COLUMN public.feedback_submissions.screenshot_url IS 'Relative path to screenshot in storage bucket';
COMMENT ON COLUMN public.feedback_submissions.device_info IS 'JSON object containing browser, OS, screen size, viewport, URL, etc.';
COMMENT ON COLUMN public.feedback_submissions.status IS 'Status of feedback: new, reviewed, or resolved';

-- Enable RLS on feedback_submissions
ALTER TABLE public.feedback_submissions ENABLE ROW LEVEL SECURITY;

-- Feedback submissions policies
-- Consolidated user and admin viewing into single policy
CREATE POLICY "Users can insert own feedback" ON public.feedback_submissions
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users and admins can view feedback" ON public.feedback_submissions
  FOR SELECT USING (
    (select auth.uid()) = user_id OR
    public.is_admin()
  );

CREATE POLICY "Users can update own feedback" ON public.feedback_submissions
  FOR UPDATE USING ((select auth.uid()) = user_id);

-- Feedback submissions indexes
CREATE INDEX idx_feedback_submissions_user_id ON public.feedback_submissions(user_id);
CREATE INDEX idx_feedback_submissions_status ON public.feedback_submissions(status);
CREATE INDEX idx_feedback_submissions_created_at ON public.feedback_submissions(created_at DESC);

-- Analytics insights cache table
CREATE TABLE public.analytics_insights (
  id bigserial PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  period text NOT NULL, -- '7d', '30d', '90d', 'all', 'custom'
  context text NOT NULL, -- 'all', 'personal', or organization ID
  start_date timestamptz, -- nullable for preset periods
  end_date timestamptz, -- nullable for preset periods
  insights jsonb NOT NULL, -- structured insights data
  summary text, -- short summary of insights for dashboard display
  generated_at timestamptz DEFAULT now(),
  expires_at timestamptz NOT NULL -- 24 hours from generated_at
);

-- Add comments for analytics_insights
COMMENT ON TABLE public.analytics_insights IS 'Cached AI-generated analytics insights for user posts';
COMMENT ON COLUMN public.analytics_insights.period IS 'Time period: 7d, 30d, 90d, all, or custom';
COMMENT ON COLUMN public.analytics_insights.context IS 'Post context: all, personal, or organization ID';
COMMENT ON COLUMN public.analytics_insights.insights IS 'JSONB object containing structured insights with title, content, category, etc.';
COMMENT ON COLUMN public.analytics_insights.summary IS 'Short summary of insights for dashboard display';
COMMENT ON COLUMN public.analytics_insights.expires_at IS 'Timestamp when cache expires (24 hours from generated_at)';

-- Enable RLS on analytics_insights
ALTER TABLE public.analytics_insights ENABLE ROW LEVEL SECURITY;

-- Analytics insights policies
CREATE POLICY "Users can view own analytics insights" ON public.analytics_insights
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own analytics insights" ON public.analytics_insights
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own analytics insights" ON public.analytics_insights
  FOR UPDATE USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can delete own analytics insights" ON public.analytics_insights
  FOR DELETE USING ((select auth.uid()) = user_id);

-- Analytics insights indexes
CREATE INDEX idx_analytics_insights_user_id ON public.analytics_insights(user_id);
CREATE INDEX idx_analytics_insights_expires_at ON public.analytics_insights(expires_at);
CREATE INDEX idx_analytics_insights_cache_key ON public.analytics_insights(user_id, period, context, start_date, end_date);

-- Unique constraint to prevent duplicate cache entries for the same time frame
CREATE UNIQUE INDEX idx_analytics_insights_unique_cache ON public.analytics_insights(user_id, period, context, COALESCE(start_date, '1970-01-01'::timestamptz), COALESCE(end_date, '1970-01-01'::timestamptz));

-- Content ideas table
CREATE TABLE public.content_ideas (
  id bigserial PRIMARY KEY,
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  ideas jsonb NOT NULL, -- array of Idea objects
  generated_at timestamptz DEFAULT now(),
  expires_at timestamptz NOT NULL -- cooldown expiration timestamp
);

-- Add comments for content_ideas
COMMENT ON TABLE public.content_ideas IS 'Persisted AI-generated content ideas for users';
COMMENT ON COLUMN public.content_ideas.ideas IS 'JSONB array of Idea objects with title, description, topic, source, articleUrl';
COMMENT ON COLUMN public.content_ideas.generated_at IS 'Timestamp when ideas were generated';
COMMENT ON COLUMN public.content_ideas.expires_at IS 'Timestamp when cooldown expires and new ideas can be generated';

-- Enable RLS on content_ideas
ALTER TABLE public.content_ideas ENABLE ROW LEVEL SECURITY;

-- Content ideas policies
CREATE POLICY "Users can view own content ideas" ON public.content_ideas
  FOR SELECT USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can insert own content ideas" ON public.content_ideas
  FOR INSERT WITH CHECK ((select auth.uid()) = user_id);

CREATE POLICY "Users can update own content ideas" ON public.content_ideas
  FOR UPDATE USING ((select auth.uid()) = user_id);

CREATE POLICY "Users can delete own content ideas" ON public.content_ideas
  FOR DELETE USING ((select auth.uid()) = user_id);

-- Content ideas indexes
CREATE INDEX idx_content_ideas_user_id ON public.content_ideas(user_id);

-- Unique constraint to ensure one set of ideas per user (replaced on next generation)
CREATE UNIQUE INDEX idx_content_ideas_user_unique ON public.content_ideas(user_id);

-- Function to increment usage counter (legacy support)
CREATE OR REPLACE FUNCTION public.increment_usage(user_id uuid)
RETURNS int
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_count int;
BEGIN
  UPDATE public.usage_counters
  SET total_generations = COALESCE(total_generations, 0) + 1
  WHERE usage_counters.user_id = increment_usage.user_id
  RETURNING total_generations INTO new_count;

  IF new_count IS NULL THEN
    INSERT INTO public.usage_counters (user_id, total_generations)
    VALUES (increment_usage.user_id, 1)
    RETURNING total_generations INTO new_count;
  END IF;

  RETURN new_count;
END;
$$;

-- Function to increment type-based usage counter
CREATE OR REPLACE FUNCTION public.increment_usage_by_type(user_id uuid, generation_type text)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  new_counts jsonb;
BEGIN
  UPDATE public.usage_counters
  SET
    generation_counts = COALESCE(generation_counts, '{}'::jsonb) ||
      jsonb_build_object(generation_type, COALESCE((generation_counts->>generation_type)::int, 0) + 1),
    total_generations = COALESCE(total_generations, 0) + 1
  WHERE usage_counters.user_id = increment_usage_by_type.user_id
  RETURNING generation_counts INTO new_counts;

  IF new_counts IS NULL THEN
    INSERT INTO public.usage_counters (user_id, generation_counts, total_generations)
    VALUES (
      increment_usage_by_type.user_id,
      jsonb_build_object(generation_type, 1),
      1
    )
    RETURNING generation_counts INTO new_counts;
  END IF;

  RETURN new_counts;
END;
$$;

-- Auto-create user profile and preferences on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (new.id, new.email);

  INSERT INTO public.user_prefs (user_id)
  VALUES (new.id);

  INSERT INTO public.usage_counters (user_id)
  VALUES (new.id);

  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Helper function to get user's portfolio ID (as owner or collaborator)
CREATE OR REPLACE FUNCTION public.get_user_portfolio_id(user_id uuid)
RETURNS uuid
LANGUAGE plpgsql
VOLATILE
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  portfolio_id_result uuid;
BEGIN
  -- Temporarily disable RLS to prevent recursion
  SET LOCAL row_security = off;

  SELECT COALESCE(
    (SELECT id FROM public.portfolios WHERE owner_id = get_user_portfolio_id.user_id),
    (SELECT portfolio_id FROM public.portfolio_collaborators
     WHERE portfolio_collaborators.user_id = get_user_portfolio_id.user_id
     AND status = 'accepted'
     LIMIT 1)
  ) INTO portfolio_id_result;

  RETURN portfolio_id_result;
END;
$$;

-- Helper function to check if user can access a post
CREATE OR REPLACE FUNCTION public.can_user_access_post(check_user_id uuid, check_post_id bigint)
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
  post_user_id uuid;
  post_portfolio_id uuid;
  post_publish_target text;
  user_portfolio_id uuid;
  is_owner boolean;
  is_collaborator boolean;
  user_has_org_access boolean;
BEGIN
  -- Get post details
  SELECT user_id, portfolio_id, publish_target
  INTO post_user_id, post_portfolio_id, post_publish_target
  FROM public.posts
  WHERE id = check_post_id;

  -- If post doesn't exist, return false
  IF post_user_id IS NULL THEN
    RETURN false;
  END IF;

  -- Creator can always access their own posts
  IF post_user_id = check_user_id THEN
    RETURN true;
  END IF;

  -- If post has no portfolio, only creator can access
  IF post_portfolio_id IS NULL THEN
    RETURN false;
  END IF;

  -- Get user's portfolio
  SELECT get_user_portfolio_id(check_user_id) INTO user_portfolio_id;

  -- If user is not in the same portfolio, deny access
  IF user_portfolio_id IS NULL OR user_portfolio_id != post_portfolio_id THEN
    RETURN false;
  END IF;

  -- Check if user is portfolio owner
  SELECT EXISTS (
    SELECT 1 FROM public.portfolios
    WHERE id = post_portfolio_id
    AND owner_id = check_user_id
  ) INTO is_owner;

  -- If user is portfolio owner, they can see all organization posts
  IF is_owner THEN
    -- Owner can see all organization posts
    IF post_publish_target IS NOT NULL AND post_publish_target != 'personal' THEN
      RETURN true;
    END IF;
  ELSE
    -- Check if user is a collaborator
    SELECT EXISTS (
      SELECT 1 FROM public.portfolio_collaborators
      WHERE portfolio_id = post_portfolio_id
      AND user_id = check_user_id
      AND status = 'accepted'
    ) INTO is_collaborator;
  END IF;

  -- For personal posts, only creator can access
  IF post_publish_target = 'personal' OR post_publish_target IS NULL THEN
    RETURN false;
  END IF;

  -- For organization posts, check if collaborator has access to that organization
  IF post_publish_target IS NOT NULL AND post_publish_target != 'personal' THEN
    SELECT EXISTS (
      SELECT 1 FROM public.linkedin_organizations
      WHERE user_id = check_user_id
      AND linkedin_org_id = post_publish_target
    ) INTO user_has_org_access;

    RETURN user_has_org_access;
  END IF;

  RETURN false;
END;
$$;
